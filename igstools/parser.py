# References:
# Muxer/Demuxer: http://patches.libav.org/patch/22445/
# Decoder:       http://patches.libav.org/patch/22446/
import struct
import io

PALETTE_SEGMENT = 0x14
PICTURE_SEGMENT = 0x15
BUTTON_SEGMENT  = 0x18
DISPLAY_SEGMENT = 0x80


def _eof_aware_read(stream, length):
    ret = stream.read(length)
    if not ret:
        return None

    if len(ret) < length:
        raise EOFError()

    return ret


def unpack_from_stream(fmt, stream):
    data = _eof_aware_read(stream, struct.calcsize(fmt))
    if not data:
        return None

    return struct.unpack(fmt, data)


def igs_raw_segments(stream):
    # All integers are in big-endian
    # ["IG"] [u32 pts] [u32 dts] [u8 seg_type] [u16 seg_length]
    while True:
        header_tuple = unpack_from_stream(">2sIIBH", stream)
        if not header_tuple:
            return

        magic, pts, dts, seg_type, seg_length = header_tuple
        if magic != b"IG":
            raise ValueError("Invalid segment header")

        raw_data = stream.read(seg_length)
        if len(raw_data) < seg_length:
            raise EOFError()

        yield {
            "pts": pts,
            "dts": dts,
            "seg_type": seg_type,
            "raw_data": raw_data,
        }


def parse_palette_segment(stream):
    ret = {
        "palette": [],
    }
    # Drop 2 useless bytes
    stream.read(2)

    while True:
        entry_data = unpack_from_stream("BBBBB", stream)
        if not entry_data:
            break

        color_id, y, cr, cb, alpha = entry_data
        ret["palette"].append({
            "color_id": color_id,
            "y": y,
            "cr": cr,
            "cb": cb,
            "alpha": alpha,
        })

    return ret


def parse_picture_segment(stream):
    # [u16 oid] [u8 ver] [u8 seq_desc] [u24 rle_bitmap_len *]
    # [u16 width] [u16 height]
    oid, ver, seq_desc, len1, len2, len3, width, height = \
        unpack_from_stream(">HBBBBBHH", stream)

    rle_bitmap_len = (len1 << 16) | (len2 << 8) | len3

    # Stored length includes width and height
    rle_bitmap_len -= 4
    return {
        "oid": oid,
        "ver": ver,
        "seq_desc": seq_desc,
        "is_continuation": not bool(seq_desc & 0x80),
        "width": width,
        "height": height,
        "rle_bitmap_len": rle_bitmap_len,
        "rle_bitmap_data": stream.read(),
    }

def parse_button_segment(stream):
    # [u16 width] [u16 height] [u8 framerate_id] [u16 unkwown] [u8 flags]
    # [u32 in_time] [u32 to]
    width, height, framerate_id, _, flags, in_time, to = \
        unpack_from_stream(">HHBHBII", stream)

    if to == 0:
        # Ten more byte skipped (output generated by TMpegEnc Authoring 5)
        _eof_aware_read(stream, 10)

    page_count = ord(stream.read(1))
    ret = {
        "width": width,
        "height": height,
        "framerate_id": framerate_id,
        "flags": flags,
        "in_time": in_time,
        "to": to,
        "pages": [],
    }
    for i in range(page_count):
        # [u8 page_id] [u8 unknown] [u64 uo] [u32 in/out_effects count]
        # [u8 framerate_divider] [u16 def_button] [u16 def_activated]
        # [u8 palette] [u8 bog_count]
        page_id, _, uo, effect_count, framerate_divider, def_button, \
            def_activated, palette, bog_count = \
            unpack_from_stream(">BBQIBHHBB", stream)

        cur_page = {
            "id": page_id,
            "uo": uo,
            "effect_count": effect_count,
            "framerate_divider": framerate_divider,
            "def_button": def_button,
            "def_activated": def_activated,
            "palette": palette,
            "bogs": [],
        }
        for j in range(bog_count):
            # [u16 def_button] [u8 button_count]
            bog_def_button, button_count = unpack_from_stream(">HB", stream)
            cur_bog = {
                "def_button": bog_def_button,
                "buttons": [],
            }
            for k in range(button_count):
                # f is u8, others are all u16
                button_id, v, f, x, y, nu, nd, nl, nr, \
                    picstart_normal, picstop_normal, flags_normal, \
                    picstart_selected, picstop_selected, flags_selected, \
                    picstart_activated, picstop_activated, cmds_count = \
                    unpack_from_stream(">HHB" + "H" * 15, stream)

                cur_bog["buttons"].append({
                    "id": button_id,
                    "v": v,
                    "f": f,
                    "x": x,
                    "y": y,
                    "navigation": {
                        "up": nu,
                        "down": nd,
                        "left": nl,
                        "right": nr,
                    },
                    "states": {
                        "normal": {
                            "start": picstart_normal,
                            "stop": picstop_normal,
                            "flags": flags_normal,
                        },
                        "selected": {
                            "start": picstart_selected,
                            "stop": picstop_selected,
                            "flags": flags_selected,
                        },
                        "activated": {
                            "start": picstart_activated,
                            "stop": picstop_activated,
                        },
                    },
                    # 3 u32 for each command
                    "commands": [unpack_from_stream(">III", stream)
                                 for x in range(cmds_count)],
                })

            cur_page["bogs"].append(cur_bog)

        ret["pages"].append(cur_page)

    return ret


def igs_segments(stream):
    ops = {
        PALETTE_SEGMENT: parse_palette_segment,
        PICTURE_SEGMENT: parse_picture_segment,
        BUTTON_SEGMENT: parse_button_segment,
        DISPLAY_SEGMENT: lambda x: {},
    }
    for seg in igs_raw_segments(stream):
        op = ops[seg["seg_type"]]
        seg.update(op(io.BytesIO(seg["raw_data"])))
        yield seg


if __name__ == '__main__':
    import debugging
    debugging.setup()
    with open("00009.mnu", "rb") as f:
        for seg in igs_segments(f):
            print("Type: 0x{:x}, Len: {}".format(
                seg["seg_type"], 
                len(seg["raw_data"])
            ))
            if seg["seg_type"] == BUTTON_SEGMENT:
                import pprint
                pprint.pprint(seg["pages"])
